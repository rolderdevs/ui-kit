# Rolder UI Kit v3

## Этот монорепо содержит:

- Элементы UI для фреймворков. Сейчас React.
- Движок независимых от фреймворка Panda CSS презетов, на базе которых создаются элементы в фреймворках.
- Движок тем (наборы токенов) Panda CSS для стандартизованой стилизации приложения и элементов.
- Один дефолтный презет и одна тема (в обоих цветовых режимах - светлая и темная).
- Выставка элементов для фреймворка.
- Демонстрационное приложение простого чата с ИИ.

## Тех. стек

- Flox для автоматической установки toolchain.
- Bun для централизованного управления пакетами в режиме монорепозитория, запуска скриптов. В бекендах служит runtime вместо Node.js.
- Panda CSS - это CSS-in-JS со статическим анализом кода. Очень удобен для сосдания элементов UI. Обеспечивает максимальную производительность приложения, т.к. собирает обычный CSS, анализируя код во время сборки.
- ARK-UI - это набор готовых элементов. Библиотека headless, т.е. не имеет стилизации.
- AI SDK от Vercel для ИИ-бекендов. На сегодня самый лучший, с точки зрения баланса простоты и возможностей.
- Фреймворки. Сейчас React только потому, что AI SDK с ним максимально интегрирован.

## Структура монорепозитория

- **design-system**: дизайн система:
  - **elements**: элементы UI:
    - **react**: фреймворк:
      - **components**: простые компоненты UI.
      - **composables**: составные мета-компоненты. Например, StreamResponse, собирающий в себе все, что нужно для верстки ответа ИИ в markdown.
      - **styled-system**: styled-system Panda CSS, берущий дефолтный прзет и тему.
      - **hooks**: хуки UI.
      - **utils**: утилиты UI.
      - **showcase**: выставка элементов.
  - **shared**: переиспользуемые функции между фреймворками.
  - **presets**: рецепты:
    - **default**: дефолтный презет Rolder:
      - **recipes**: простые рецепты.
      - **slotRecipes**: рецепты с слотами.
  - **themes**: темы. Для каждой темы задаются токены - цвета, отступы, размеры и т.д. А так же глобальные стили, шрифты.
    - **default**: дефолтная тема Rolder.
- **apps**: демонстрационные приложения:
  - **simpleChat**: простой чат с ИИ.
    - **frontend**: фронтенд приложения.
    - **backend**: бэкенд приложения.

## Как это работает

Каждый **элемент UI** минимально собирается из двух частей:

- **recipe**: рецепт элемента UI. Рецепт сам по себе не зависит от фреймворка. По сути это инструкция для генерации CSS при сборке. Может быть простым, когда задается один класс CSS и настройки для него. Может быть составным, тогда задается несколько классов (слоты).
- **logic**: логика работы элемента UI.

Помимо этого могут использоваться переиспользуемые функции в рамках одного фреймворка или между ними.

**Тема** задается отдельно, но элементы сильно от нее зависят, т.к. в рецепте используются токены темы - цвета, размеры и другое. Для смягчения это связи тема следует стандарту с помощью семантических токенов. Например, в теме задаются кастомные цвета. Они называются как угодно. Создаются семантические токены для цветов. Например, text, которые имеет два варианта - default и muted. Эти варианты ссылаются на кастомные цвета, а рецепт ссылается на семантический токен. Таким образом можно в нодном месте менять цвет текста для всей темы, не меняя рецепты всех элементов. Здесь стандарт - это название цвета "text" и название его вариантов.

**В готовый элемент UI** все части собираются по месту в итоговом приложении. Т.е. изначально у элемента нет стилей, только логика. Panda смотрит как в коде был применен элемент UI и генерирует только то, что было применено. Например, если в коде использована кнопка с вариантом `secondary` и размером `lg`, то в CSS появится - 2 класса для этих вариантов и все токены, что эти варианты используют, а так же все токены, что заданы в базовой части рецепта. При этом все токены темы уже есть в CSS. Сам же код элемента уберет всю логику применения классов, оставив только массив текстов выбранных классов. В итоговом приложении не остается кода JS относительно стилей, только чистый HTML+CSS.

## Процесс разработки элемента UI

**Фаза 1:**

1. Создается/дорабатывается рецепт.
2. Создается/дорабатывается логика элемента с примененным рецептом.
3. Дорабатывается тема, если нужно.
4. Элемент добавляется в выставку, чтобы иметь возможность оценивать его визульно.

Фаза повторяется, пока элемент не готов. На этом этапе мы относимся к элементу универсально, т.е. делаем его пригодным в разных приложениях. При этом, следует помнить про все базовые паттерны разработки - https://habr.com/ru/companies/itelma/articles/546372/ Особенно обращу внимание на YAGNI (Вам это не понадобится). Если кажется, что что-то пригодится, то кажется )

**Фаза 2:**

1. Берем/создаем демонстрационное приложение и применяем элемент там.
2. Дорабатываем элемент, обнаружив недостатки.
3. Деплоим приложение для проверки в бою. Бывает, что при деплое что-то теряется, лезут особенности.

Эта фаза приблежает в понимании реального использования элемента и отлавливает глюки, что не поймать в фазе 1.

**Фаза 3** предполагает реальное использование элемента в разных приложениях. Опыт использовния возвращает нас к первым фазам.
